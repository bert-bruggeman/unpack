#!/bin/sh


UTIL_NAME="$(basename ${0})"
UTIL_VERSION="20130621"

function help () {
cat <<EOF
Usage: ${UTIL_NAME} [OPTION]... ARCHIVE
Unpack ARCHIVE to current directory if archive containts only one item
(file or directory) or to new directory named after archive name if
archive containts more than one item.

Options
  -h         show help
  -v         show all processing info during unpacking
  -s         print result file or directory path
  --version  print script version
EOF
}

function version () {
    echo "${UTIL_VERSION}"
}

# Delete termporary directory on interrupt
function sig_terminate () {
    rm -rf "${TMP_DIR}" > /dev/null
    if [ -n "${DST}" ]
    then
        rm -rf "${DST}" > /dev/null
    fi
    exit 0
}
trap "sig_terminate" SIGINT SIGHUP SIGTERM


# Parse arguments
TEMP=$(getopt -o hsv -l help,version -n "${UTIL_NAME}" -- "$@")
if [ $? != 0 ] ; then echo "Try '${UTIL_NAME} --h' for more information." >&2 ; exit 1 ; fi
eval set -- "$TEMP"
while true ; do
    case "$1" in
	-h|--help)
            help
            exit 0
            ;;
        --version)
            version
            exit 0
            ;;
	-v)
            VERBOSE="TRUE"
            shift
            ;;
	-s)
	    SHOW_RES="TRUE"
            shift
            ;;
	--)
	    shift
            break
            ;;
    esac
done

# Check number of arguments
if [ "${#}" -gt 2 -o "${#}" -lt 1 ]
then
    help
    exit 1
fi


# File to unpack
ARCHIVE=$(readlink -f "${1}")
ARCHIVE_NAME=$(basename "${ARCHIVE}")
ARCHIVE_DIR=$(dirname "${ARCHIVE}")

# Check file existance
if [ ! -f "${ARCHIVE}" ]
then
    echo "${UTIL_NAME}: cannot find ${ARCHIVE}: no such archive file" >&2
    exit 1
fi

# Archive basename and extension (defined as substring after last '.')
EXT=$(basename "${ARCHIVE_NAME}" | sed '/\./!s/.*//;/\./s/.*\.//' | tr [:upper:] [:lower:])
if [ -z "${EXT}" ]; then
    echo "${UTIL_NAME}: file ${ARCHIVE} is not archive: cannot separate extension" >&2
    exit 1
fi
BASENAME=$(basename "${ARCHIVE}" .${EXT})
# Subextension (defined as part after penult dot) and corresponding basename
SUB_EXT=$(echo "${BASENAME}" | sed '/\./!s/.*//;/\./s/.*\.//' | tr [:upper:] [:lower:])
if [ -n "${SUB_EXT}" ]; then
    SUB_BASENAME=$(basename "${ARCHIVE_NAME}" ."${SUB_EXT}"."${EXT}")
fi

# If sub-extension is 'tar' - use it as part of whole extension (like
# 'tar.gz' instead of 'gz')
if [ "${SUB_EXT}" = "tar" ]
then
    EXT="${SUB_EXT}.${EXT}"
    BASENAME="${SUB_BASENAME}"
fi

# Temporary extraction path 
TMP_DIR=$(mktemp -u -d -t ${UTIL_NAME}.XXXXXXXXXXXXX --tmpdir=.)
TMP_DIR=$(readlink -f "${TMP_DIR}")

# Extract archive contant to the temporary directory
# Each case must unpack archive with path ${ARCHIVE} to directory
# ${TMP_DIR}.
# Hint: If corresponding unpacking tool doesn't support target
# directory specification - copy archive to directory previously
mkdir "${TMP_DIR}"
case "${EXT}" in
    "rar")
        if [ -n "${VERBOSE}" ]
        then
            unrar x "${ARCHIVE}" "${TMP_DIR}"
        else
            unrar x "${ARCHIVE}" "${TMP_DIR}" &> /dev/null
        fi
        ;;
    "zip")
        if [ -n "${VERBOSE}" ]
        then
            unzip -d "${TMP_DIR}" "${ARCHIVE}"
        else
            unzip -d "${TMP_DIR}" "${ARCHIVE}" &> /dev/null
        fi
        ;;
    "7z")
        cd "${TMP_DIR}"
        if [ -n "${VERBOSE}" ]
        then
            7z e  "${ARCHIVE}"
        else
            7z e "${ARCHIVE}" &> /dev/null
        fi
        cd "${OLDPWD}"
        ;;
    "tar" | "tar.bz2" | "tar.gz" | "tar.xz" | "tar.lzma" | "tgz" | "tbz" | "txz")
        if [ -n "${VERBOSE}" ]
        then
            tar xvf "${ARCHIVE}" -C "${TMP_DIR}"
        else
            tar xf "${ARCHIVE}" -C "${TMP_DIR}" &> /dev/null
        fi
        ;;
    "bz2")
        mkdir -p "${TMP_DIR}"
        if [ -n "${VERBOSE}" ]
        then
            bzcat -v "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}"
        else
            bzcat "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}" 2> /dev/null
        fi
        ;;
    "gz")
        mkdir -p "${TMP_DIR}"
        if [ -n "${VERBOSE}" ]
        then
            gunzip -v -c "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}"
        else
            gunzip -c "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}" 2> /dev/null
        fi
        ;;
    "xz")
        mkdir -p "${TMP_DIR}"
        if [ -n "${VERBOSE}" ]
        then
            xzcat -v -c "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}"
        else
            xzcat -c "${ARCHIVE}" > "${TMP_DIR}/${BASENAME}" 2> /dev/null
        fi
        ;;
    "deb")
        cd "${TMP_DIR}"
        if [ -n "${VERBOSE}" ]
        then
            ar xv "${ARCHIVE}"
        else
            ar x "${ARCHIVE}" &> /dev/null
        fi
        cd "${OLDPWD}"
        ;;
    "rpm")
        if [ -n "${VERBOSE}" ]
        then
            rpm2cpio "${ARCHIVE}" | cpio -idmuv --no-absolute-filenames "${TMP_DIR}"
        else
            rpm2cpio "${ARCHIVE}" | cpio -idmuv --no-absolute-filenames --quiet "${TMP_DIR}"
        fi
        ;;
    *)
        echo "${UTIL_NAME}: unknown archive format '${EXT}'"
        rm -rf "${TMP_DIR}" &> /dev/null
        exit 1
        ;;
esac


# Get number of files extracted from archive
NUM_OF_FILES=$(ls -1 "${TMP_DIR}" | wc -l)
if [ "${NUM_OF_FILES}" = "1" ]
# If it is a single file or directory - unpack it to current directory
then
    DST=$(pwd)/$(ls "${TMP_DIR}")
    ITEM=$(readlink -f "${TMP_DIR}"/*)
    ITEM=$(basename "${ITEM}")
    SRC="${TMP_DIR}"/"${ITEM}"
    # If such file or directory already exists - act like there is
    # several file in archive
    if [ -e "${ITEM}" ]
    then
        DST=$(readlink -f ./"${BASENAME}")
        SRC="${TMP_DIR}"
    fi
# If there is more than one files in archive - unpack to directory
# named after acrhive basename
else
    DST=$(readlink -f ./"${BASENAME}")
    SRC="${TMP_DIR}"
fi

# Check if such file or directory already exists
if [ -e "${DST}" ]
then
    echo "${UTIL_NAME}: cannot unpack '$(basename ${DST})': such file already exists in current directory"
    rm -rf "${TMP_DIR}"
    exit 1
fi

# Move archive to destination
mv "${SRC}" "${DST}"

# Remove temporary derictory if it's still exists
rm -rf "${TMP_DIR}" &> /dev/null

# Show result file or directory path if needed
if [ -n "${SHOW_RES}" ]
then
    echo "${DST}"
fi
